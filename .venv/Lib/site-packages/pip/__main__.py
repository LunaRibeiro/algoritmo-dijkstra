import pygame
import heapq

# Configurações
WIDTH, HEIGHT = 600, 600
ROWS, COLS = 30, 30
CELL_SIZE = WIDTH // COLS
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GREY = (200, 200, 200)
BLUE = (0, 0, 255)
GREEN = (0, 255, 0)
RED = (255, 0, 0)
PURPLE = (160, 32, 240)

pygame.init()
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Dijkstra em Ação")

# Cria uma matriz de células
grid = [[0 for _ in range(COLS)] for _ in range(ROWS)]


def draw_grid():
    for row in range(ROWS):
        for col in range(COLS):
            color = WHITE
            if grid[row][col] == 1:
                color = BLACK
            pygame.draw.rect(screen, color, (col * CELL_SIZE, row * CELL_SIZE, CELL_SIZE, CELL_SIZE))

    for x in range(0, WIDTH, CELL_SIZE):
        pygame.draw.line(screen, GREY, (x, 0), (x, HEIGHT))
    for y in range(0, HEIGHT, CELL_SIZE):
        pygame.draw.line(screen, GREY, (0, y), (WIDTH, y))


def get_neighbors(pos):
    row, col = pos
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]
    neighbors = []
    for dr, dc in directions:
        r, c = row + dr, col + dc
        if 0 <= r < ROWS and 0 <= c < COLS and grid[r][c] != 1:
            neighbors.append((r, c))
    return neighbors


def dijkstra(start, end):
    distances = {start: 0}
    came_from = {}
    visited = set()
    heap = [(0, start)]

    while heap:
        current_dist, current = heapq.heappop(heap)

        if current in visited:
            continue
        visited.add(current)

        if current == end:
            break

        for neighbor in get_neighbors(current):
            new_dist = current_dist + 1
            if neighbor not in distances or new_dist < distances[neighbor]:
                distances[neighbor] = new_dist
                came_from[neighbor] = current
                heapq.heappush(heap, (new_dist, neighbor))

        if current != start:
            pygame.draw.rect(screen, BLUE, (current[1] * CELL_SIZE, current[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE))
        pygame.display.update()

    return came_from


def reconstruct_path(came_from, start, end):
    current = end
    while current != start:
        current = came_from.get(current)
        if current is None or current == start:
            break
        pygame.draw.rect(screen, PURPLE, (current[1] * CELL_SIZE, current[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE))
        pygame.display.update()


def main():
    running = True
    start, end = None, None
    started = False

    while running:
        screen.fill(WHITE)
        draw_grid()

        # Redesenha os pontos de início e fim
        if start:
            pygame.draw.rect(screen, GREEN, (start[1] * CELL_SIZE, start[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE))
        if end:
            pygame.draw.rect(screen, RED, (end[1] * CELL_SIZE, end[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE))

        pygame.display.update()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if pygame.mouse.get_pressed()[0]:  # Botão esquerdo
                x, y = pygame.mouse.get_pos()
                row, col = y // CELL_SIZE, x // CELL_SIZE
                if not start and grid[row][col] != 1:
                    start = (row, col)
                elif not end and (row, col) != start and grid[row][col] != 1:
                    end = (row, col)
                elif (row, col) != start and (row, col) != end:
                    grid[row][col] = 1

            if pygame.mouse.get_pressed()[2]:  # Botão direito
                x, y = pygame.mouse.get_pos()
                row, col = y // CELL_SIZE, x // CELL_SIZE
                if (row, col) == start:
                    start = None
                elif (row, col) == end:
                    end = None
                grid[row][col] = 0

            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and start and end and not started:
                    started = True
                    came_from = dijkstra(start, end)
                    reconstruct_path(came_from, start, end)

                if event.key == pygame.K_r:
                    start, end = None, None
                    started = False
                    for row in range(ROWS):
                        for col in range(COLS):
                            grid[row][col] = 0

    pygame.quit()


if __name__ == "__main__":
    main()
